{"version":3,"sources":["../src/utils.js"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import 'setimmediate';\nimport scryptAsync from 'scrypt-async';\nimport { keystore as Keystore } from 'eth-lightwallet';\n\nexport const apiEndpoint = 'http://localhost/api/v1/keystore';\n\n/**\n *  Generate random 12 word seed\n *\n *  @method          generateRandomSeed\n *  @param           {String}                    _entropy          Additional entropy\n *  @return          {String}                    12 word string\n */\nexport function generateRandomSeed(_entropy) {\n  return Keystore.generateRandomSeed(_entropy);\n}\n\n/**\n *  Get password derived key from password\n *\n *  @method          deriveKey\n *  @param           {String}           _password          Keystore password\n *  @return          {Promise}          pwDerivedKey\n */\nfunction deriveKey(_password) {\n  return new Promise((resolve, reject) => {\n    Keystore.deriveKeyFromPassword(_password, (err, pwDerivedKey) => {\n      if (!err) {\n        resolve(pwDerivedKey);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n\n/**\n *  Scrypt async promise wrapper\n *\n *  @type          {Object}\n */\nconst scrypt = {\n  /**\n   *  Create scrypt hash\n   *\n   *  @method          hash\n   *  @param           {String}           _password          String to hash\n   *  @param           {Int}              options.N          LogN\n   *  @param           {Int}              options.r          r\n   *  @param           {Int}              options.p          p\n   *  @param           {Int}              _length            Hash length in bytes\n   *  @param           {String}           _salt              Salt\n   *  @return          {Promise}          hex-encoded hash\n   */\n  hash(_password, { N, r, p }, _length, _salt) {\n    return new Promise((resolve, reject) => {\n      scryptAsync(_password, _salt, N, r, _length, p, (hash) => {\n        if (hash) {\n          return resolve(hash);\n        }\n\n        return reject();\n      }, 'hex');\n    });\n  },\n};\n\n/**\n *  Validate auth arguments\n *\n *  @method          validateTokenInput\n *  @param           {String}                    _identifier          Account identifier\n *  @param           {String}                    _password            Account password\n *  @return          {Promise}                   payload\n */\nfunction validateTokenInput(_identifier, _password) {\n  // - implement validator\n  return new Promise((resolve, reject) => {\n    if (_identifier === '') {\n      reject('Identifier is required');\n    }\n\n    if (_password === '' || _password.length < 5) {\n      reject('A password is required');\n    }\n\n    resolve({ _identifier, _password });\n  });\n}\n\n/**\n *  Encrypt Password before sending it to the server\n *\n *  @method          getToken\n *  @param           {String}          _identifier          Account identifier\n *  @param           {String}          _password            Account password\n *  @return          {Promise}         hashed password\n */\nexport function getToken(_identifier, _password) {\n  return validateTokenInput(_identifier, _password)\n    .then(() => scrypt.hash(_password, { N: 11, r: 8, p: 200 }, 256, _identifier))\n    .then(result => result.toString('hex'));\n}\n\n/**\n *  Generate keystore and eth address\n *\n *  @method          generateAddress\n *  @param           {String}                 _password          Account password\n *  @param           {String}                 _seed              12 word seed\n *  @param           {String}                 _entropy           Additional entropy\n *  @return          {Promise}                Keystore\n */\nexport function generateAddress(_password, _seed = '', _entropy = '') {\n  return deriveKey(_password)\n    .then(_pwDerivedKey => {\n      const ks = new Keystore((_seed || generateRandomSeed(_entropy)), _pwDerivedKey);\n      ks.generateNewAddress(_pwDerivedKey);\n\n      return ks;\n    });\n}\n\n/**\n *  Prepare request headers\n *\n *  @method          makeRequestHeaders\n *  @param           {String}                    options.method        GET, PUT, POST, PATCH, DELETE\n *  @param           {String}                    options.token         JWT Auth token\n *  @param           {Object}                    options.payload       Request payload\n *  @return          {Object}                    Request Headers\n */\nexport function makeRequestHeaders({ method, token, payload } = {}) {\n  const defaultOptions = {\n    method: method || 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    credentials: 'include',\n  };\n\n  const options = Object.assign({}, defaultOptions);\n\n  if (payload) {\n    options.body = JSON.stringify(payload);\n  }\n\n  if (token) {\n    options.headers = Object.assign({}, options.headers, { Authorization: token });\n  }\n\n  // console.log(options);\n\n  return options;\n}\n\n/**\n *  Check response status\n *\n *  @method          checkResponseStatus\n *  @param           {Object}                     response          Response object\n *  @return          {Object}                     response\n */\nexport function checkResponseStatus(response) {\n  // console.dir(response); // eslint-disable-line no-console\n  // if (response.status < 200 || response.status >= 300) {\n  //   const error = new Error(response.statusText);\n  //   error.response = response;\n\n  //   throw error;\n  // }\n\n  return response;\n}\n\n/**\n *  Parse JSON response\n *\n *  @method          parseJSON\n *  @param           {Object}           response          Response object\n *  @return          {Object}           response\n */\nexport function parseJSON(response) {\n  return response.json();\n}\n\n/**\n *  Check is response is successful\n *\n *  @method          checkResponseSuccess\n *  @param           {Object}                      response          Response object\n *  @return          {Object}                      response\n */\nexport function checkResponseSuccess(response) {\n  if (response.status !== 'success') {\n    const error = new Error(response.error);\n\n    throw error;\n  }\n\n  return response;\n}\n"]}